# Read a SID JSON file and Generate a C header file with stubs for all the SID functions

# Import argparse and write a command line parser to accept .sid file as input
# Read the .sid file and parse it as JSON
import argparse
import json

cborTypeToCMapping = {
    "uint8": "uint8_t",
    "uint16": "uint16_t",
    "uint32": "uint32_t",
    "uint64": "uint64_t",
    "int8": "int8_t",
    "int16": "int16_t",
    "int32": "int32_t",
    "int64": "int64_t",
    "float32": "float",
    "float64": "double",
    "decimal64": "double",
    "boolean": "bool",
    "binary" : "bool",
    "string": "char *",
    "bytes": "uint8_t *",
    "array": "uint8_t *",
    "identityref" : "char *",
    "void" : "void"
}


def formatIdentifier(identifier):
    """
    Format the identifier by replacing "/", "-", ":" with "_"
    """
    # Capitalize the letter next to "-"
    while "-" in identifier:
        index = identifier.index("-")
        identifier = identifier[:index] + identifier[index+1].upper() + identifier[index+2:]

    identifier = identifier.replace("/", "_").replace(":", "_")
    # Remove the leading "_"
    if identifier[0] == "_":
        identifier = identifier[1:]

    # Shorten it, take the last word after "_" and use it as the identifier
    identifier = identifier.split("_")[-1]

    return identifier

class SIDItem:
    def __init__(self, namespace, identifier, sid, type_=None, stable=False):
        self.namespace = namespace
        self.identifier = identifier
        self.sid = sid
        self.stable = stable
        self.sidKeyItems = []
        if type_:
            # NOTE fix this later
            if type(type_) == list:
                self.type = "void"
            else:
                self.type = type_
            self.checkType()
        else:
            self.type = "void"

    def checkType(self):
        # Ideally this should come from libcbor?
        if self.type not in cborTypeToCMapping:
            raise Exception("Invalid type: " + self.type)
        
    def addSidKey(self, sidKeyItem):
        self.sidKeyItems.append(sidKeyItem)
    
    def generateDocStrings(self):
        """
        Generate C documentation String for the sidKey of the form:
            /*
            This is an autogenerated function associated to 
            SID:
            Module: 
            Identifier:
            function params: (ruleIdValue, ruleIdLength)
            Stable:
            */
        """
        docStringTemplate = """
/*
    This is an autogenerated function associated to 
    SID: %s
    Module: %s 
    Identifier: %s
    function params: %s
    Stable: %s
*/\n"""

        docString = docStringTemplate % (self.sid, self.namespace, self.identifier, ", ".join([x.identifier for x in self.sidKeyItems]), str(self.stable))
        return docString

    def generateFunctionBody(self):
        """
        Invoke manipulateCORECONF function properly
        """
        functionBodyTemplate = """{
    int64_t keys[] = {%s};
    size_t keyLength = %s;
    IdentifierSIDT *sidIdentifier = malloc(sizeof(IdentifierSIDT));
    sidIdentifier->sid = INT64_MIN;
    sidIdentifier->identifier = "%s";
    json_t *traversedJSON_ = traverseCORECONFWithKeys(instance, sidModel, sidIdentifier, keys, keyLength);
    free(sidIdentifier);
    return traversedJSON_;
}
        """

        functionBody = functionBodyTemplate % (", ".join([str(x.sid) for x in self.sidKeyItems]), str(len(self.sidKeyItems)), self.identifier);
        return functionBody

    def generateCGetMethods(self):
        """
        Generate C code for this item, the sidKeys will be passed as parameters to the function
        """
        getString = "get_"
        # Don't do anything if the namespace is not "data"
        if self.namespace != "data":
            return ""
        
        # generate docstrings
        docString = self.generateDocStrings()

        # generate function name from the self.identifier by replacing "/" with "_"
        functionName = formatIdentifier(self.identifier)
        # generate C function argument string from the sidKeyItems
        ### MODIFY FROM HERE, function args should contain any keys if its required
        functionArgs = "json_t *instance, SIDModelT *sidModel, "
        functionBody = self.generateFunctionBody() if self.sidKeyItems else "{\n\t}"

        # If no sidKeyItems are found directly return the function string
        if not self.sidKeyItems:
            functionString = docString + cborTypeToCMapping[self.type] + " " + getString + functionName + "()" + functionBody + "\n"
            return functionString

        lastSidKeyItem = self.sidKeyItems[-1]
        for sidKeyItem in self.sidKeyItems:
            # check if sidKeyItem is the last item in the list
            if sidKeyItem == lastSidKeyItem:
                # if yes, then don't add the comma
                functionArgs += cborTypeToCMapping[sidKeyItem.type] + " " +  formatIdentifier(sidKeyItem.identifier)   
            else:
                functionArgs += cborTypeToCMapping[sidKeyItem.type] + " " +  formatIdentifier(sidKeyItem.identifier) + ", "

        # generate C function return type from the self.type
        #functionReturnType = cborTypeToCMapping[self.type]
        functionReturnType = "json_t *"
        functionString = docString + functionReturnType + " " + getString + functionName + "(" + functionArgs + ")" + functionBody + "\n"
        return functionString

def findIdentifierBlockBySID(sid, items):
    """
    Iterate through items and return the dictionary which matches the sid number
    """
    for item in items:
        if item["sid"] == sid:
            return item
    return {}

def findIdentifierBlockByIdentifier(identifier, items):
    """
    Iterate through items and return the dictionary which matches the identifier
    """
    for item in items:
        if item["identifier"] == identifier:
            return item
    return {}

def generateMapping(items):
    """
    NOTE items is not just dataItems, it is all the items in the sid file
    Generate a dictionary of the form:
    {
        "identifier1": sid1,
        "identifier2": sid2
    }
    """
    identifierSIDKeyMapping = {}
    sidKeyIdentifierMapping = {}
    for item in items:
        identifierSIDKeyMapping[item["identifier"]] = item["sid"]
        sidKeyIdentifierMapping[item["sid"]] = item["identifier"]
    return identifierSIDKeyMapping, sidKeyIdentifierMapping

def getSetOfKeysOfKeyMapping(keyMapping, identifierSIDKeyMapping):
    """
    Returns a set of all the keys in keyMapping
    """
    keySet = set()
    for identifierKey, keyList in keyMapping.items():
        # Find SID for identifierKey
        sidKey = identifierSIDKeyMapping[identifierKey]

        for key in keyList:
            keySet.add( identifierSIDKeyMapping[key])

    return keySet

def findKeysForLeaves(itemIdentifier, keyMapping, identifierSIDKeyMapping):
    """
    Returns a list of keys for a leafIdentifier
    """
    itemSID = identifierSIDKeyMapping[itemIdentifier]
    requiredSIDKeys = []

    # If itemIdentifier is itself in keyMapping, then add its keys to requiredSIDKeySet
    if itemIdentifier in keyMapping:
        sidKeys = keyMapping[itemIdentifier]
        for sidKey in sidKeys:
            requiredSIDKeys.append(identifierSIDKeyMapping[sidKey])

    # Check if its parents are in keyMapping and add their keys to requiredSIDKeySet
    identifier = itemIdentifier
    while (identifier):
        identifier = identifier.rsplit("/", 1)[0]
        if identifier in keyMapping:
            # Should you keep the sidKey : keyList or just the keyList in this set?
            # Add the sidKey to requiredSIDKeys
            sidKeys = keyMapping[identifier]
            for sidKey in sidKeys:
                requiredSIDKeys.append( identifierSIDKeyMapping[sidKey] )

    return requiredSIDKeys

def main():
    # write a command line parser to accept .sid file as input
    parser = argparse.ArgumentParser(description='Generate a C header file with stubs for all the SID functions')
    parser.add_argument('input', metavar='input', type=str, help='The input .sid file')
    #parser.add_argument('output', metavar='output', type=str, help='The output .h file')
    args = parser.parse_args()

    includeString = "#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <coreconf.h>\n"

    # read the .sid file and parse it as JSON
    with open(args.input, 'r') as f:
        sidJSON = json.load(f)

    # Read "key-mapping" from sidJSON
    keyMapping = sidJSON["key-mapping"]
    # Read "items" from sidJSON
    items = sidJSON["items"]

    identifierSIDKeyMapping, sidKeyIdentifierMapping = generateMapping(items)
    # keySet is a set of all the keys which have been used in keyMapping
    sidKeySet = getSetOfKeysOfKeyMapping(keyMapping, identifierSIDKeyMapping)


    # Iterate through items and find items with namespace "data"
    dataItems = []
    for item in items:
        if item["namespace"] == "data":
            # check if item is in keyMapping
            itemSID = item["sid"]
            itemIdentifier = item["identifier"]
            # NOTE Remember key-mapping now has identifiers in instead of SIDs
            if itemIdentifier in keyMapping:
                # Find out the keys for this item
                sidKeys = keyMapping[itemIdentifier]

            dataItems.append(item)

    # Iterate through dataItems and generate C code for each item
    cCode = ""

    """
     dataReadings (json_t instance, uint8_t readingIndex){}
    healthReadings(json_t instance, uint8_t readingIndex){}
    // get keys to reach this healthValue
    get_healthValue_key(json_t* instance,  get_healthValue)
    get_battery_key((json_t* instance,  get_healthValue)
    get_dataValue_key(json_t* instance,  get_healthValue)
    """

    for item in dataItems:
        itemIdentifier = item["identifier"]
        itemSID = item["sid"]
        itemType = item.get("type")
        # Ignore items which are keys
        if itemSID in sidKeySet:
            continue

        # Ignore item type if its a identityref
        if itemType == "identityref":
            continue
        
        # Generate C code for this item
        sidItem = SIDItem(item["namespace"], itemIdentifier, itemSID, itemType, item.get("stable", "false"))
        # Find out the keys for this item

        # Generate C code for this item
        sidKeys = findKeysForLeaves(itemIdentifier, keyMapping, identifierSIDKeyMapping)
       
        # Find item block for corresponding sidKeys
        for sidKey in sidKeys:
            # Find the sidKeyItem from items
            sidKeyItemMap = findIdentifierBlockBySID(sidKey, items)
            if not sidKeyItemMap:
                raise Exception("No item found for sid key: " + str(sidKey["sid"]))
            sidKeyItem = SIDItem(sidKeyItemMap["namespace"], sidKeyItemMap["identifier"], sidKeyItemMap["sid"], sidKeyItemMap.get("type"), item.get("stable"))
            sidItem.addSidKey(sidKeyItem)

        cCode += sidItem.generateCGetMethods() + "\n"

    # print the C code to stdout
    print(includeString)
    print(cCode)

if __name__ == "__main__":
    main()